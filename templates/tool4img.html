<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tool 4 Img | 이미지 편집 도구</title>
    <script async src="https://docs.opencv.org/master/opencv.js" type="text/javascript"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 5px;
        }
        
        .description {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .upload-container {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            background-color: #f9f9f9;
        }
        
        .upload-container:hover {
            border-color: #007aff;
            background-color: #f0f8ff;
        }
        
        .upload-container.highlight {
            border-color: #007aff;
            background-color: #f0f8ff;
        }
        
        .upload-container p {
            margin: 0;
            color: #666;
        }
        
        .upload-btn {
            background-color: #007aff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: background-color 0.3s;
        }
        
        .upload-btn:hover {
            background-color: #0056b3;
        }
        
        .preview-container {
            display: none;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #preview {
            max-width: 100%;
            max-height: 500px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .controls { /* Main controls container */
            display: flex; 
            flex-direction: column; 
            /* align-items: center; */ /* Removed: Let groups align naturally inside */
            gap: 20px; 
            margin-bottom: 20px;
            /* Added for centering the container itself */
            max-width: 600px; /* Match control group max-width */
            margin-left: auto;
            margin-right: auto;
        }
        
        /* Control Group Styling */
        .control-group {
            width: 100%; /* Groups take full width of the centered .controls */
            /* max-width: 600px; */ /* No longer needed here if .controls has it */
        }
        
        .control-group h3 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .control-btn {
            background-color: #f2f2f2;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background-color: #e6e6e6;
        }
        
        .control-btn.active {
            background-color: #007aff;
            color: white;
            border-color: #007aff;
        }
        
        .slider-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin: 10px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007aff;
            cursor: pointer;
        }
        
        .download-btn {
            display: none;
            background-color: #34c759;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 0;
            transition: background-color 0.3s;
            display: block;
        }
        
        .download-btn:hover {
            background-color: #2aa44f;
        }
        
        .text-input {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .color-picker {
            margin-top: 5px;
        }

        /* Export Controls Section Styling */
        .export-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px; 
            margin-bottom: 20px; 
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 10px;
            border: 1px solid #eee;
        }

        .export-controls .input-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            width: 100%;
        }

        .export-controls .input-group {
            display: flex;
            align-items: center;
            gap: 5px; 
        }

        .export-controls .text-input {
            margin-top: 0; 
            width: 80px; 
            padding: 6px 8px; 
            font-size: 14px; 
        }

        .export-controls label {
            margin-bottom: 0; 
            font-size: 14px;
        }

        /* Download button specific adjustments within export controls */
        .export-controls .download-btn {
            padding: 10px 25px;
            font-size: 15px;
            margin-top: 0; 
            margin-bottom: 0; 
        }

        /* Export Controls Section Styling */
        .export-controls .btn-group {
            justify-content: space-around;
            width: 100%;
        }

        /* New classes for adjustment and transform controls */
        .adjustment-group {
            margin-bottom: 15px;
        }
        
        .transform-group {
            margin-bottom: 15px;
        }
        
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-start;
            width: 100%;
        }
        
        .half-width {
            flex-basis: calc(50% - 8px);
            flex-grow: 1;
        }
        
        .btn-group.half-width {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: space-around;
        }

        .btn-group.half-width .control-btn {
             flex-basis: calc(50% - 4px);
             flex-grow: 1;
             text-align: center;
        }

        /* Canvas styling for free crop mode */
        #preview.cropping {
            cursor: crosshair;
        }

        /* Apply/Cancel button styling */
        .apply-btn {
            background-color: #34c759; /* Green */
            color: white;
            border-color: #34c759;
        }
        .apply-btn:hover {
            background-color: #2aa44f;
        }
        .cancel-btn {
            background-color: #ff3b30; /* Red */
            color: white;
            border-color: #ff3b30;
        }
        .cancel-btn:hover {
            background-color: #c62a20;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tool 4 Img | 이미지 편집 도구</h1>
        
        <div class="upload-container" id="upload-area">
            <p>이미지를 드래그하여 놓거나</p>
            <button class="upload-btn" id="upload-btn">파일 선택하기</button>
            <input type="file" id="file-input" accept="image/*" style="display: none;">
        </div>
        
        <div class="preview-container" id="preview-container">
            <canvas id="preview"></canvas>
        </div>
        
        <div class="controls" id="controls">
            <!-- Adjustment Controls -->
            <div class="control-group adjustment-group">
                <h3>조정</h3>
                <div class="controls-row">
                    <div class="slider-container half-width">
                        <label>밝기: <span id="brightness-value">0</span></label>
                        <input type="range" id="brightness-slider" min="-100" max="100" value="0">
                    </div>
                    <div class="slider-container half-width">
                        <label>대비: <span id="contrast-value">0</span></label>
                        <input type="range" id="contrast-slider" min="-100" max="100" value="0">
                    </div>
                </div>
            </div>
            
            <!-- Transform Controls -->
            <div class="control-group transform-group">
                <h3>회전 및 반전</h3>
                <div class="controls-row">
                    <div class="slider-container half-width">
                        <label>회전: <span id="rotation-value">0</span>°</label>
                        <input type="range" id="rotation-slider" min="-45" max="45" value="0">
                    </div>
                    <div class="btn-group half-width">
                        <button class="control-btn" id="rotate-left-btn">좌로 90°</button>
                        <button class="control-btn" id="rotate-right-btn">우로 90°</button>
                        <button class="control-btn" id="flip-h-btn">좌우 반전</button>
                        <button class="control-btn" id="flip-v-btn">상하 반전</button>
                    </div>
                </div>
            </div>
            
            <div class="control-group advanced-group">
                <h3>고급</h3>
                <div class="btn-group">
                    <button class="control-btn" id="free-crop-btn">자유 크롭</button>
                    <button class="control-btn" id="rectangle-btn">사각형</button>
                    <button class="control-btn" id="highlighter-btn">형광펜</button>
                    <button class="control-btn" id="text-btn">텍스트</button>
                </div>
                <div id="crop-actions" style="display: none; margin-top: 10px; justify-content: center;" class="btn-group">
                    <button class="control-btn apply-btn" id="apply-crop-btn">크롭 적용</button>
                    <button class="control-btn cancel-btn" id="cancel-crop-btn">취소</button>
                    </div>
                <div id="drawing-controls" style="display: none; margin-top: 10px;">
                    <div class="slider-container">
                        <label>크기: <span id="drawing-size-value">20</span></label>
                        <input type="range" id="drawing-size-slider" min="5" max="50" value="20">
                </div>
                    </div>
                <div id="text-input-container" style="display: none; margin-top: 10px; width: 100%;">
                    <div style="display: flex; justify-content: space-around; align-items: center; width: 100%;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label for="text-size-input">크기: </label>
                            <input type="number" id="text-size-input" min="5" max="50" value="40" class="text-input" style="width: 60px;">
                    </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label for="text-color-input">색상: </label>
                            <input type="color" id="text-color-input" value="#000000" class="color-picker">
                        </div>
                        <div style="display: flex; align-items: center;">
                            <label for="text-input">텍스트: </label>
                            <input type="text" id="text-input" placeholder="Press Enter" class="text-input" style="width: 150px;">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Export Controls (Already at bottom) -->
             <div class="control-group export-controls" id="export-controls">
                 <!-- ... input-row for width/height/format ... -->
                 <div class="input-row">
                     <div class="input-group">
                         <label for="width-input">너비: </label>
                         <input type="number" id="width-input" class="text-input">
                </div>
                     <div class="input-group">
                         <label for="height-input">높이: </label>
                         <input type="number" id="height-input" class="text-input">
                    </div>
                     <div class="input-group">
                         <label for="format-select">포맷: </label>
                         <select id="format-select" class="text-input">
                             <option value="png">PNG</option>
                             <option value="jpeg">JPEG</option>
                             <option value="webp">WEBP</option>
                         </select>
                    </div>
                </div>
                 <!-- Buttons row -->
                 <div class="btn-group">
                     <button class="control-btn" id="reset-btn">원본으로 돌아가기</button>
                     <button class="download-btn" id="download-btn">이미지 다운로드</button>
                 </div>
            </div>
        </div>
        

    </div>

    <script>
        // OpenCV.js 모듈 초기화
        var Module = {
            onRuntimeInitialized: function() {
                console.log('OpenCV.js is ready');
                initImageEditor();
            }
        };

        // OpenCV.js 로드 실패 처리
        function onOpenCvError() {
            console.error('OpenCV.js 로드 실패');
            alert('이미지 편집 기능을 사용할 수 없습니다. 페이지를 새로고침해주세요.');
        }
        
        // 변수 초기화
        let originalImage = null;
        let originalImageBackup = null; // 원본 이미지 백업
        let displayedImageMat = null;
        let isFlippedHorizontal = false;
        let isFlippedVertical = false;
        let discreteRotationAngle = 0; // For 90-degree steps (0, 90, 180, 270)
        
        // Free Cropping state variables
        let isFreeCropping = false;
        let isDraggingCropRect = false;
        let startCropX, startCropY, endCropX, endCropY;
        let selectionRect = null; // { x, y, width, height } in canvas coordinates
        
        // 그리기 모드 관련 변수
        let isDrawingMode = false;
        let currentDrawingMode = null;
        let isDragging = false;
        let startX, startY, endX, endY;
        let textInput = null;
        let textPosition = null;
        let drawings = [];
        let drawingSize = 20;
        let lastX = null;
        let lastY = null;
        
        // DOM Elements (Add crop related)
        const preview = document.getElementById('preview');
        const uploadArea = document.getElementById('upload-area');
        const uploadBtn = document.getElementById('upload-btn');
        const fileInput = document.getElementById('file-input');
        const previewContainer = document.getElementById('preview-container');
        const controls = document.getElementById('controls');
        const downloadBtn = document.getElementById('download-btn');
        const exportControls = document.getElementById('export-controls');
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');
        const formatSelect = document.getElementById('format-select');
        
        // 슬라이더 요소
        const rotationSlider = document.getElementById('rotation-slider');
        const brightnessSlider = document.getElementById('brightness-slider');
        const contrastSlider = document.getElementById('contrast-slider');
        
        // Free Crop Button Listener
        const freeCropBtn = document.getElementById('free-crop-btn'); // Button to toggle free crop
        const cropActions = document.getElementById('crop-actions'); // Container for Apply/Cancel
        const applyCropBtn = document.getElementById('apply-crop-btn');
        const cancelCropBtn = document.getElementById('cancel-crop-btn');
        
        // 그리기 모드 버튼 이벤트 리스너
        document.getElementById('rectangle-btn').addEventListener('click', () => toggleDrawingMode('rectangle'));
        document.getElementById('highlighter-btn').addEventListener('click', () => toggleDrawingMode('highlighter'));
        document.getElementById('text-btn').addEventListener('click', () => toggleDrawingMode('text'));
        document.getElementById('text-input').addEventListener('keypress', handleTextInput);
        
        // 캔버스 이벤트 리스너
        preview.addEventListener('mousedown', handleMouseDown);
        preview.addEventListener('mousemove', handleMouseMove);
        preview.addEventListener('mouseup', handleMouseUp);
        preview.addEventListener('click', handleCanvasClick);
        
        // 이미지 에디터 초기화
        function initImageEditor() {
            // 이벤트 리스너 설정
            uploadBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', handleFileSelect);
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('highlight');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('highlight');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('highlight');
                
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    handleFileSelect(e);
                }
            });
            
            // 컨트롤 버튼 이벤트 리스너
            document.getElementById('reset-btn').addEventListener('click', resetImage);
            document.getElementById('rotate-left-btn').addEventListener('click', rotate90CounterClockwise);
            document.getElementById('rotate-right-btn').addEventListener('click', rotate90Clockwise);
            document.getElementById('flip-h-btn').addEventListener('click', flipHorizontal);
            document.getElementById('flip-v-btn').addEventListener('click', flipVertical);
            document.getElementById('download-btn').addEventListener('click', downloadImage);
            
            // 슬라이더 이벤트
            rotationSlider.addEventListener('input', updateImageEffects);
            brightnessSlider.addEventListener('input', updateImageEffects);
            contrastSlider.addEventListener('input', updateImageEffects);

            // Free Crop Button Listener
            freeCropBtn.addEventListener('click', () => toggleDrawingMode('crop'));
            applyCropBtn.addEventListener('click', applyFreeCrop); // Renamed apply function
            cancelCropBtn.addEventListener('click', cancelFreeCrop); // Renamed cancel function

            // Width/height listeners
            widthInput.addEventListener('input', handleWidthInput);
            heightInput.addEventListener('input', handleHeightInput);

            // 그리기 크기 슬라이더 이벤트 리스너
            const drawingSizeSlider = document.getElementById('drawing-size-slider');
            drawingSizeSlider.addEventListener('input', function() {
                drawingSize = parseInt(this.value);
                document.getElementById('drawing-size-value').textContent = drawingSize;
                updateImageEffects();
            });
        }
        
        // 너비 입력 시 높이 자동 조정
        function handleWidthInput() {
            if (!originalImage || originalImage.isDeleted()) return;
            
            const originalAspectRatio = originalImage.cols / originalImage.rows;
            if (isNaN(originalAspectRatio) || originalAspectRatio <= 0) return; // Avoid division by zero or invalid ratio
            
            const newWidth = parseInt(widthInput.value);
            
            if (!isNaN(newWidth) && newWidth > 0) {
                 const newHeight = Math.round(newWidth / originalAspectRatio);
                 if (newHeight > 0) { // Only update if calculated height is valid
                      // Prevent infinite loops by checking if the value actually changes significantly
                      if (Math.abs(parseInt(heightInput.value) - newHeight) > 1) { 
                           heightInput.value = newHeight;
                      }
                 } else {
                      // If calculated height is invalid, maybe clear or reset?
                      // For now, do nothing to avoid weird states.
                 }
            } 
        }
        
        // 높이 입력 시 너비 자동 조정
        function handleHeightInput() {
            if (!originalImage || originalImage.isDeleted()) return;
            
            const originalAspectRatio = originalImage.cols / originalImage.rows;
            if (isNaN(originalAspectRatio) || originalAspectRatio <= 0) return;
            
            const newHeight = parseInt(heightInput.value);
            
            if (!isNaN(newHeight) && newHeight > 0) {
                 const newWidth = Math.round(newHeight * originalAspectRatio);
                 if (newWidth > 0) {
                      if (Math.abs(parseInt(widthInput.value) - newWidth) > 1) {
                           widthInput.value = newWidth;
                      }
                 } else {
                      // Handle invalid calculated width
                 }
            }
        }
        
        // 파일 선택 처리
        async function handleFileSelect(e) {
            const file = fileInput.files[0];
            if (!file) return;
            
            // Hide controls immediately while loading new image
            controls.style.display = 'none';
            exportControls.style.display = 'none'; 
            previewContainer.style.display = 'none';
            
            const reader = new FileReader();
            
            reader.onload = async function(event) {
                const img = new Image();
                img.onload = async function() {
                    try {
                        // 이전 이미지 메모리 해제
                        if (originalImage) originalImage.delete();
                        if (originalImageBackup) originalImageBackup.delete();
                        if (displayedImageMat) displayedImageMat.delete();
                        
                        cv = (cv instanceof Promise) ? await cv : cv;
                        
                        // 원본 이미지 생성 및 백업
                        originalImage = cv.imread(img);
                        originalImageBackup = originalImage.clone(); // 원본 이미지 백업 생성
                        
                        // UI 업데이트
                        uploadArea.style.display = 'none';
                        previewContainer.style.display = 'block';
                        controls.style.display = 'block';
                        exportControls.style.display = 'flex';
                        
                        // 초기 너비/높이 설정 (Reset 전에 수행)
                        widthInput.value = originalImage.cols;
                        heightInput.value = originalImage.rows;
                        
                        // 슬라이더 리셋 및 초기 이미지 표시
                        resetSlidersAndDisplay(); 
                    } catch (error) {
                        console.error('[handleFileSelect] 이미지 처리 중 오류 발생:', error);
                        alert('이미지 로딩 중 오류가 발생했습니다.');
                        // Reset UI if loading fails
                        uploadArea.style.display = 'block';
                        previewContainer.style.display = 'none';
                        controls.style.display = 'none';
                        exportControls.style.display = 'none';
                    }
                };
                img.onerror = function() {
                     console.error('[handleFileSelect] 이미지 파일 로드 실패');
                     alert('이미지 파일을 읽는 중 오류가 발생했습니다.');
                     uploadArea.style.display = 'block'; // Show upload area again
                };
                img.src = event.target.result;
            };
            reader.onerror = function() {
                 console.error('[handleFileSelect] FileReader 오류');
                 alert('파일을 읽는 중 오류가 발생했습니다.');
                 uploadArea.style.display = 'block'; // Show upload area again
            };
            reader.readAsDataURL(file);
        }
        
        // 슬라이더 리셋 및 이미지 업데이트 헬퍼 함수
        function resetSlidersAndDisplay() {
            const sliders = [
                { element: rotationSlider, valueId: 'rotation-value' },
                { element: brightnessSlider, valueId: 'brightness-value' },
                { element: contrastSlider, valueId: 'contrast-value' }
            ];
            sliders.forEach(({ element, valueId }) => {
                element.value = 0;
                document.getElementById(valueId).textContent = '0';
            });

            // Reset flips and discrete rotation
            isFlippedHorizontal = false;
            isFlippedVertical = false;
            discreteRotationAngle = 0;

            // Reset width/height inputs to current originalImage dimensions
            if (originalImage && !originalImage.isDeleted()) {
                widthInput.value = originalImage.cols;
                heightInput.value = originalImage.rows;
            }

            updateImageEffects();
        }
        
        // 이미지 리셋 (버튼 클릭 시)
        function resetImage() {
            if (!originalImageBackup) return;
            try {
                // 현재 이미지 메모리 해제
                if (originalImage) originalImage.delete();
                if (displayedImageMat) displayedImageMat.delete();
                
                // 백업된 원본 이미지로 복원
                originalImage = originalImageBackup.clone();
                
                // 그린 요소들 초기화
                drawings = [];
                
                // 슬라이더 및 상태 초기화
                resetSlidersAndDisplay(); 
                console.log('이미지 및 모든 효과가 원본으로 복원되었습니다.');
            } catch (error) {
                console.error('[resetImage] 이미지 리셋 중 오류 발생:', error);
                alert('이미지 복원 중 오류가 발생했습니다.');
            }
        }

        // 90도 회전 함수들
        function rotate90Clockwise() {
            discreteRotationAngle = (discreteRotationAngle + 90) % 360;
            console.log(`Discrete Rotation: ${discreteRotationAngle}`);
            updateImageEffects();
        }

        function rotate90CounterClockwise() {
            discreteRotationAngle = (discreteRotationAngle - 90 + 360) % 360; // Ensure positive modulo
            console.log(`Discrete Rotation: ${discreteRotationAngle}`);
            updateImageEffects();
        }
        
        // 이미지 효과 업데이트 (90도 회전 로직 추가)
        function updateImageEffects() {
            if (!originalImage) return;
            let M = null;
            let initialRotated = null;
            let finalTransformed = null;

            try {
                // --- Get current slider/state values --- 
                const fineRotation = parseInt(rotationSlider.value); // Rotation from slider
            const brightness = parseInt(brightnessSlider.value);
            const contrast = parseInt(contrastSlider.value);
                // discreteRotationAngle, isFlippedHorizontal, isFlippedVertical are global states
            
                // --- Update displayed slider values --- 
                document.getElementById('rotation-value').textContent = fineRotation;
            document.getElementById('brightness-value').textContent = brightness;
            document.getElementById('contrast-value').textContent = contrast;
            
                // --- Effect Pipeline Start --- 
                // 1. Apply Discrete 90-degree Rotation (if any)
                let currentSrc = originalImage.clone(); // Start from original
                if (discreteRotationAngle !== 0) {
                    let rotateCode;
                    if (discreteRotationAngle === 90) rotateCode = cv.ROTATE_90_CLOCKWISE;
                    else if (discreteRotationAngle === 180) rotateCode = cv.ROTATE_180;
                    else if (discreteRotationAngle === 270) rotateCode = cv.ROTATE_90_COUNTERCLOCKWISE;
                    
                    if (rotateCode !== undefined) {
                        initialRotated = new cv.Mat();
                        cv.rotate(currentSrc, initialRotated, rotateCode);
                        currentSrc.delete(); // Delete the previous step's Mat
                        currentSrc = initialRotated; // Result of 90-degree rotation is now current source
                    } else {
                         initialRotated = currentSrc; // No rotation, pass through
                    }
                } else {
                    initialRotated = currentSrc; // No discrete rotation needed
                }
                
                // 2. Apply Fine Rotation (Slider) using warpAffine
                const center = new cv.Point(initialRotated.cols / 2, initialRotated.rows / 2);
                M = cv.getRotationMatrix2D(center, fineRotation, 1.0);
                const rad = fineRotation * Math.PI / 180.0;
                const cos = Math.abs(M.data64F[0]);
                const sin = Math.abs(M.data64F[1]);
                // Calculate bounding box based on dimensions *after* 90-degree rotation
                const newWidth = Math.round(initialRotated.rows * sin + initialRotated.cols * cos);
                const newHeight = Math.round(initialRotated.rows * cos + initialRotated.cols * sin);
                const dsize = new cv.Size(newWidth, newHeight);
                M.data64F[2] += (newWidth / 2.0) - center.x;
                M.data64F[5] += (newHeight / 2.0) - center.y;

                finalTransformed = new cv.Mat(dsize, initialRotated.type());
                cv.warpAffine(initialRotated, finalTransformed, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                M.delete(); M = null;
                initialRotated.delete(); // Delete the result from step 1

                // 3. Apply Brightness/Contrast
                finalTransformed.convertTo(finalTransformed, -1, 1 + contrast / 100, brightness);
                
                // 4. Apply Flips
                if (isFlippedHorizontal) cv.flip(finalTransformed, finalTransformed, 1);
                if (isFlippedVertical) cv.flip(finalTransformed, finalTransformed, 0);
                // --- Effect Pipeline End ---

                // --- Store/Update the base displayed Mat --- 
                if (displayedImageMat && !displayedImageMat.isDeleted()) { displayedImageMat.delete(); }
                displayedImageMat = finalTransformed; // Track the final result
                
                // --- Update canvas size and display --- 
                preview.width = newWidth; 
                preview.height = newHeight;
                if (displayedImageMat && !displayedImageMat.isDeleted()) {
                    cv.imshow('preview', displayedImageMat); 
                } else {
                    console.error("Mat to display is invalid in updateImageEffects");
                }

                // 회전 후의 너비와 높이를 입력 필드에 업데이트
                widthInput.value = newWidth;
                heightInput.value = newHeight;

                // --- Drawing Logic --- 
                if (isDrawingMode) {
                    // 기존 그린 요소들을 먼저 표시
                    const ctx = preview.getContext('2d');
                    drawings.forEach(drawing => {
                        if (drawing.type === 'rectangle') {
                            ctx.strokeStyle = 'red';
                            ctx.lineWidth = drawing.size || drawingSize;
                            ctx.strokeRect(drawing.x, drawing.y, drawing.width, drawing.height);
                        } else if (drawing.type === 'highlighter') {
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                            ctx.lineWidth = drawing.size || drawingSize;
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            
                            if (drawing.points.length > 1) {
                                ctx.beginPath();
                                ctx.moveTo(drawing.points[0].x, drawing.points[0].y);
                                for (let i = 1; i < drawing.points.length; i++) {
                                    ctx.lineTo(drawing.points[i].x, drawing.points[i].y);
                                }
                                ctx.stroke();
                            }
                        } else if (drawing.type === 'text') {
                            ctx.fillStyle = drawing.color || 'black';
                            ctx.font = `${drawing.size || drawingSize}px Arial`;
                            ctx.fillText(drawing.text, drawing.x, drawing.y);
                        }
                    });

                    // 드래그 중인 사각형 표시
                    if (currentDrawingMode === 'rectangle' && isDragging) {
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = drawingSize;
                        const x = Math.min(startX, endX);
                        const y = Math.min(startY, endY);
                        const width = Math.abs(startX - endX);
                        const height = Math.abs(startY - endY);
                        ctx.strokeRect(x, y, width, height);
                    }
                } else if (isFreeCropping && (isDraggingCropRect || selectionRect)) {
                     // If cropping AND a rect should be drawn, draw it
                     drawSelectionRectangle(); // This func clones displayedImageMat & draws rect
                } else {
                     // Otherwise, just show the base result
                     if (displayedImageMat && !displayedImageMat.isDeleted()) {
                          cv.imshow('preview', displayedImageMat); 
                     } else {
                          console.error("Mat to display is invalid in updateImageEffects (non-cropping)");
                     }
                }
                // --- End Drawing Logic --- 

            } catch (error) {
                console.error('[updateImageEffects] 이미지 효과 적용 중 오류 발생:', error);
                // Clean up intermediate mats if error occurred mid-pipeline
                if (initialRotated && !initialRotated.isDeleted()) initialRotated.delete();
                if (finalTransformed && finalTransformed.isDeleted()) { displayedImageMat = null; }
            } finally {
                if (M && !M.isDeleted()) M.delete();
                // finalTransformed is tracked by displayedImageMat
            }
        }

        // 좌우 반전 (상태 변경 후 업데이트 호출)
        function flipHorizontal() {
            if (!originalImage) return;
            isFlippedHorizontal = !isFlippedHorizontal;
            updateImageEffects();
        }
        
        // 상하 반전 (상태 변경 후 업데이트 호출)
        function flipVertical() {
            if (!originalImage) return;
            isFlippedVertical = !isFlippedVertical;
            updateImageEffects();
        }

        // 다운로드 함수 수정 (90도 회전 반영)
        function downloadImage() {
            if (!originalImage) { /* ... error handling ... */ return; }

            const canvas = document.getElementById('preview');
            const link = document.createElement('a');
            const format = formatSelect.value;
            const filename = `edited-image.${format}`;
            let M = null;
            let initialRotated = null;
            let finalTransformed = null;
            let imageToDraw = null;

            try {
                // --- Get current slider/state/input values --- 
                const fineRotation = parseInt(rotationSlider.value);
                const brightness = parseInt(brightnessSlider.value);
                const contrast = parseInt(contrastSlider.value);
                const requestedWidth = parseInt(widthInput.value); 
                const requestedHeight = parseInt(heightInput.value);
                // discreteRotationAngle, isFlippedHorizontal, isFlippedVertical are global

                // --- Effect Pipeline (Download Version) --- 
                // 1. Apply Discrete 90-degree Rotation
                let currentSrc = originalImage.clone();
                if (discreteRotationAngle !== 0) {
                    let rotateCode;
                    if (discreteRotationAngle === 90) rotateCode = cv.ROTATE_90_CLOCKWISE;
                    else if (discreteRotationAngle === 180) rotateCode = cv.ROTATE_180;
                    else if (discreteRotationAngle === 270) rotateCode = cv.ROTATE_90_COUNTERCLOCKWISE;
                    
                    if (rotateCode !== undefined) {
                        initialRotated = new cv.Mat();
                        cv.rotate(currentSrc, initialRotated, rotateCode);
                        currentSrc.delete();
                        currentSrc = initialRotated;
                    } else {
                        initialRotated = currentSrc;
                    }
                } else {
                    initialRotated = currentSrc;
                }

                // 2. Apply Fine Rotation (Slider)
                const center = new cv.Point(initialRotated.cols / 2, initialRotated.rows / 2);
                M = cv.getRotationMatrix2D(center, fineRotation, 1.0);
                const rad = fineRotation * Math.PI / 180.0;
                const cos = Math.abs(M.data64F[0]);
                const sin = Math.abs(M.data64F[1]);
                const rotWidth = Math.round(initialRotated.rows * sin + initialRotated.cols * cos);
                const rotHeight = Math.round(initialRotated.rows * cos + initialRotated.cols * sin);
                const rotDsize = new cv.Size(rotWidth, rotHeight);
                M.data64F[2] += (rotWidth / 2.0) - center.x;
                M.data64F[5] += (rotHeight / 2.0) - center.y;

                finalTransformed = new cv.Mat(rotDsize, initialRotated.type());
                cv.warpAffine(initialRotated, finalTransformed, M, rotDsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                M.delete(); M = null;
                initialRotated.delete(); 

                // 3. Apply Brightness/Contrast
                finalTransformed.convertTo(finalTransformed, -1, 1 + contrast / 100, brightness);

                // 4. Apply Flips
                if (isFlippedHorizontal) cv.flip(finalTransformed, finalTransformed, 1);
                if (isFlippedVertical) cv.flip(finalTransformed, finalTransformed, 0);
                // --- Effect Pipeline End --- 

                // 5. 리사이즈 (요청 시)
                const finalWidth = requestedWidth > 0 ? requestedWidth : finalTransformed.cols;
                const finalHeight = requestedHeight > 0 ? requestedHeight : finalTransformed.rows;

                imageToDraw = finalTransformed;
                if (finalWidth !== finalTransformed.cols || finalHeight !== finalTransformed.rows) {
                    imageToDraw = new cv.Mat();
                    let finalDsize = new cv.Size(finalWidth, finalHeight);
                    cv.resize(finalTransformed, imageToDraw, finalDsize, 0, 0, cv.INTER_AREA);
                    if (imageToDraw !== finalTransformed) {
                        finalTransformed.delete();
                        finalTransformed = null;
                    }
                }

                // 6. 최종 이미지 캔버스에 그리기
                canvas.width = finalWidth;
                canvas.height = finalHeight;
                cv.imshow(canvas, imageToDraw);

                // 7. 다운로드 트리거
                const dataUrl = canvas.toDataURL(`image/${format}`);
                link.download = filename;
                link.href = dataUrl;
            link.click();

            } catch (error) {
                 console.error("[downloadImage] 다운로드 중 오류 발생:", error);
                 alert("이미지 다운로드 중 오류가 발생했습니다.");
            } finally {
                 // Mat 메모리 정리
                 if (M && !M.isDeleted()) M.delete();
                 if (initialRotated && !initialRotated.isDeleted()) initialRotated.delete();
                 if (finalTransformed && !finalTransformed.isDeleted()) finalTransformed.delete(); 
                 if (imageToDraw && imageToDraw !== finalTransformed && !imageToDraw.isDeleted()) imageToDraw.delete(); 
            }
        }
        
        // 그리기 모드 토글 수정
        function toggleDrawingMode(mode) {
            // 모든 고급 기능 버튼 비활성화
            document.getElementById('free-crop-btn').classList.remove('active');
            document.getElementById('rectangle-btn').classList.remove('active');
            document.getElementById('highlighter-btn').classList.remove('active');
            document.getElementById('text-btn').classList.remove('active');
            
            // 모든 컨트롤 숨김
            document.getElementById('crop-actions').style.display = 'none';
            document.getElementById('drawing-controls').style.display = 'none';
            document.getElementById('text-input-container').style.display = 'none';
            
            if (currentDrawingMode === mode) {
                // 같은 모드 다시 클릭 시 비활성화
                isDrawingMode = false;
                currentDrawingMode = null;
                isFreeCropping = false;
                selectionRect = null;
                isDraggingCropRect = false;
                preview.classList.remove('cropping');
                removeFreeCropListeners();
                updateImageEffects();
            } else {
                // 다른 모드 활성화
                if (mode === 'crop') {
                    isFreeCropping = true;
                    isDrawingMode = false;
                    currentDrawingMode = null;
                    document.getElementById('free-crop-btn').classList.add('active');
                    document.getElementById('crop-actions').style.display = 'flex';
                    preview.classList.add('cropping');
                    addFreeCropListeners();
                } else {
                    isDrawingMode = true;
                    isFreeCropping = false;
                    currentDrawingMode = mode;
                    
                    if (mode === 'text') {
                        document.getElementById('text-btn').classList.add('active');
                        document.getElementById('text-input-container').style.display = 'flex';
                        document.getElementById('text-input').value = '';
                    } else {
                        document.getElementById('drawing-controls').style.display = 'block';
                        if (mode === 'rectangle') {
                            document.getElementById('rectangle-btn').classList.add('active');
                        } else if (mode === 'highlighter') {
                            document.getElementById('highlighter-btn').classList.add('active');
                        }
                    }
                }
            }
        }

        // Add canvas listeners for free crop
        function addFreeCropListeners() {
            preview.addEventListener('mousedown', handleMouseDownFreeCrop);
            preview.addEventListener('mousemove', handleMouseMoveFreeCrop);
            preview.addEventListener('mouseup', handleMouseUpFreeCrop);
            preview.addEventListener('mouseleave', handleMouseLeaveFreeCrop);
        }

        // Remove canvas listeners for free crop
        function removeFreeCropListeners() {
            preview.removeEventListener('mousedown', handleMouseDownFreeCrop);
            preview.removeEventListener('mousemove', handleMouseMoveFreeCrop);
            preview.removeEventListener('mouseup', handleMouseUpFreeCrop);
            preview.removeEventListener('mouseleave', handleMouseLeaveFreeCrop);
        }

        // Mousedown handler for free crop
        function handleMouseDownFreeCrop(e) {
            if (!isFreeCropping) return;
            isDraggingCropRect = true;
            const { x, y } = getScaledMouseCoordinates(e);
            startCropX = x;
            startCropY = y;
            endCropX = x;
            endCropY = y;
            selectionRect = null; // Clear previous selection
            e.preventDefault();
        }

        // Mousemove handler for free crop
        function handleMouseMoveFreeCrop(e) {
            if (!isFreeCropping || !isDraggingCropRect) return;
            const { x, y } = getScaledMouseCoordinates(e);
            endCropX = x;
            endCropY = y;
            drawSelectionRectangle(); // Draw temporary rect
        }

        // Mouseup handler for free crop
        function handleMouseUpFreeCrop(e) {
            if (!isFreeCropping || !isDraggingCropRect) return;
            isDraggingCropRect = false;
            const { x: finalX, y: finalY } = getScaledMouseCoordinates(e);
            endCropX = finalX;
            endCropY = finalY;

            const x = Math.min(startCropX, endCropX);
            const y = Math.min(startCropY, endCropY);
            const width = Math.abs(startCropX - endCropX);
            const height = Math.abs(startCropY - endCropY);

            if (width > 1 && height > 1) {
                selectionRect = { x, y, width, height };
                drawSelectionRectangle(); // Draw final green rect
            } else {
                selectionRect = null; // Invalid selection
                updateImageEffects(); // Redraw without rect
            }
        }

        // Mouseleave handler for free crop
        function handleMouseLeaveFreeCrop(e) {
            if (isDraggingCropRect) { // If dragging off canvas, cancel drag
                isDraggingCropRect = false;
                selectionRect = null;
                updateImageEffects(); // Redraw without rect
            }
        }

        // Draw selection rectangle (yellow while dragging, green when final)
        function drawSelectionRectangle() {
            if (!displayedImageMat || displayedImageMat.isDeleted()) return;
        
            // 크롭 전 이미지를 항상 표시
            cv.imshow('preview', displayedImageMat);
        
            // 캔버스 컨텍스트를 사용하여 사각형을 그립니다
            const ctx = preview.getContext('2d');
            ctx.strokeStyle = isDraggingCropRect ? 'yellow' : 'green';
            ctx.lineWidth = 2;
            
            if (selectionRect) { // Draw final green rectangle
                ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
            } else if (isDraggingCropRect) { // Draw yellow rectangle while dragging
                const x = Math.min(startCropX, endCropX);
                const y = Math.min(startCropY, endCropY);
                const width = Math.abs(startCropX - endCropX);
                const height = Math.abs(startCropY - endCropY);
                ctx.strokeRect(x, y, width, height);
            }
        }

        // 캔버스 이벤트 처리
        function handleMouseDown(e) {
            if (!isDrawingMode) return;
            
            const { x, y } = getScaledMouseCoordinates(e);
            isDragging = true;
            startX = x;
            startY = y;
            endX = x;
            endY = y;
            lastX = x;
            lastY = y;
            
            if (currentDrawingMode === 'highlighter') {
                drawings.push({
                    type: 'highlighter',
                    points: [{x, y}],
                    size: drawingSize
                });
            }
            
            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (!isDrawingMode || !isDragging) return;
            
            const { x, y } = getScaledMouseCoordinates(e);
            endX = x;
            endY = y;
            
            if (currentDrawingMode === 'highlighter' && lastX !== null && lastY !== null) {
                const lastDrawing = drawings[drawings.length - 1];
                if (lastDrawing && lastDrawing.type === 'highlighter') {
                    lastDrawing.points.push({x, y});
                }
                lastX = x;
                lastY = y;
            }
            
            updateImageEffects();
        }

        function handleMouseUp(e) {
            if (!isDrawingMode || !isDragging) return;
            
            isDragging = false;
            const { x, y } = getScaledMouseCoordinates(e);
            endX = x;
            endY = y;
            lastX = null;
            lastY = null;

            if (currentDrawingMode === 'rectangle') {
                const rectX = Math.min(startX, endX);
                const rectY = Math.min(startY, endY);
                const rectWidth = Math.abs(startX - endX);
                const rectHeight = Math.abs(startY - endY);
                
                if (rectWidth > 5 && rectHeight > 5) {
                    drawings.push({
                        type: 'rectangle',
                        x: rectX,
                        y: rectY,
                        width: rectWidth,
                        height: rectHeight,
                        size: drawingSize
                    });
                }
            }
            
            updateImageEffects();
        }

        function handleCanvasClick(e) {
            if (!isDrawingMode) return;
            
            const { x, y } = getScaledMouseCoordinates(e);
            
            if (currentDrawingMode === 'text') {
                textPosition = { x, y };
                document.getElementById('text-input').focus();
            }
        }

        function handleTextInput(e) {
            if (e.key === 'Enter' && textPosition) {
                const text = e.target.value;
                if (text) {
                    drawText(text, textPosition.x, textPosition.y);
                    e.target.value = '';
                    textPosition = null;
                }
            }
        }

        function drawText(text, x, y) {
            const textSize = parseInt(document.getElementById('text-size-input').value) || 20;
            const textColor = document.getElementById('text-color-input').value;
            
            drawings.push({
                type: 'text',
                text: text,
                x: x,
                y: y,
                size: textSize,
                color: textColor
            });
            updateImageEffects();
        }

        // Get scaled mouse coordinates relative to canvas
        function getScaledMouseCoordinates(e) {
            const rect = preview.getBoundingClientRect();
            const scaleX = preview.width / rect.width;
            const scaleY = preview.height / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }
        
        // 페이지 언로드 시 메모리 정리
        window.addEventListener('beforeunload', () => {
            if (originalImage) originalImage.delete();
            if (originalImageBackup) originalImageBackup.delete();
            if (displayedImageMat) displayedImageMat.delete();
        });

        // Apply the free crop
        function applyFreeCrop() {
            if (!selectionRect || !originalImage) {
                console.warn('크롭 영역이 선택되지 않았거나 원본 이미지가 없습니다.');
                return;
            }
        
            let currentTransformed = null;
            let croppedMat = null;
            let M = null;
            let newOriginal = null;
            let initialRotated = null;
        
            try {
                // --- Re-apply effects (rotation, brightness, flip) --- 
                const fineRotation = parseInt(rotationSlider.value); 
                const brightness = parseInt(brightnessSlider.value);
                const contrast = parseInt(contrastSlider.value);
            
                let currentSrc = originalImage.clone();
                if (discreteRotationAngle !== 0) {
                    let rotateCode;
                    if (discreteRotationAngle === 90) rotateCode = cv.ROTATE_90_CLOCKWISE;
                    else if (discreteRotationAngle === 180) rotateCode = cv.ROTATE_180;
                    else if (discreteRotationAngle === 270) rotateCode = cv.ROTATE_90_COUNTERCLOCKWISE;
                    if (rotateCode !== undefined) {
                        initialRotated = new cv.Mat();
                        cv.rotate(currentSrc, initialRotated, rotateCode);
                        currentSrc.delete();
                        currentSrc = initialRotated;
                    } else {
                        initialRotated = currentSrc;
                    }
                } else {
                    initialRotated = currentSrc;
                }
                
                const center = new cv.Point(initialRotated.cols / 2, initialRotated.rows / 2);
                M = cv.getRotationMatrix2D(center, fineRotation, 1.0);
                const rad = fineRotation * Math.PI / 180.0;
                const cos = Math.abs(M.data64F[0]);
                const sin = Math.abs(M.data64F[1]);
                const rotWidth = Math.round(initialRotated.rows * sin + initialRotated.cols * cos);
                const rotHeight = Math.round(initialRotated.rows * cos + initialRotated.cols * sin);
                const rotDsize = new cv.Size(rotWidth, rotHeight);
                M.data64F[2] += (rotWidth / 2.0) - center.x;
                M.data64F[5] += (rotHeight / 2.0) - center.y;
        
                currentTransformed = new cv.Mat(rotDsize, initialRotated.type());
                cv.warpAffine(initialRotated, currentTransformed, M, rotDsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
                M.delete(); M = null;
                initialRotated.delete(); 
        
                currentTransformed.convertTo(currentTransformed, -1, 1 + contrast / 100, brightness);
                if (isFlippedHorizontal) cv.flip(currentTransformed, currentTransformed, 1);
                if (isFlippedVertical) cv.flip(currentTransformed, currentTransformed, 0);
                // --- End Re-applying effects ---
        
                // --- Define and Apply Crop using scaled selectionRect ---
                const scaleX = currentTransformed.cols / preview.width;
                const scaleY = currentTransformed.rows / preview.height;
                
                const cropX = Math.max(0, Math.round(selectionRect.x * scaleX));
                const cropY = Math.max(0, Math.round(selectionRect.y * scaleY));
                const cropW = Math.min(Math.round(selectionRect.width * scaleX), currentTransformed.cols - cropX);
                const cropH = Math.min(Math.round(selectionRect.height * scaleY), currentTransformed.rows - cropY);

                if (cropW <= 0 || cropH <= 0) throw new Error("유효하지 않은 크롭 영역입니다 (scaled).");
                let rect = new cv.Rect(cropX, cropY, cropW, cropH);
                
                console.log("Applying scaled crop rect:", rect);
                
                croppedMat = currentTransformed.roi(rect); 
                newOriginal = croppedMat.clone(); 
                // --- End Crop ---
                
                // --- Clean up old original and set new one ---
                if (originalImage) originalImage.delete();
                originalImage = newOriginal; 
                
                // --- Reset drawings array ---
                drawings = [];
                
                // --- Reset State and UI --- 
                // Exit crop mode FIRST
                isFreeCropping = false;
                selectionRect = null;
                isDraggingCropRect = false;
                preview.classList.remove('cropping');
                cropActions.style.display = 'none';
                document.getElementById('free-crop-btn').classList.remove('active');
                removeFreeCropListeners();
                
                // Reset sliders/flips/discrete rotation
                resetSlidersAndDisplay(); // This now resets width/height inputs too
        
                // --- Final Update Display --- 
                // updateImageEffects will be called by resetSlidersAndDisplay
                console.log('자유 크롭 적용 완료');
        
            } catch (error) {
                console.error('[applyFreeCrop] 크롭 적용 중 오류 발생:', error);
                alert('크롭 적용 중 오류가 발생했습니다.');
                cancelFreeCrop(); // Try to cancel gracefully
            } finally {
                // Clean up temporary Mats
                if (M && !M.isDeleted()) M.delete();
                if (initialRotated && !initialRotated.isDeleted()) initialRotated.delete();
                if (currentTransformed && !currentTransformed.isDeleted()) currentTransformed.delete();
                if (croppedMat && !croppedMat.isDeleted()) croppedMat.delete();
            }
        }

        // Cancel the free crop operation
        function cancelFreeCrop() {
            if (isFreeCropping) {
                isFreeCropping = false;
                selectionRect = null;
                isDraggingCropRect = false;
                preview.classList.remove('cropping');
                cropActions.style.display = 'none';
                document.getElementById('free-crop-btn').classList.remove('active');
                removeFreeCropListeners();
                updateImageEffects();
                console.log('Free crop cancelled');
            }
        }
    </script>
</body>
</html>
