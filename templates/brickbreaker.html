<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë²½ëŒê¹¨ê¸° - SNS ê³µìœ  ê²Œì„</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-98HYEXD6V2"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-98HYEXD6V2');
    </script>

    <!-- SEO ê¸°ë³¸ ë©”íƒ€ -->    
    <meta name="description" content="ë²½ëŒì„ ê¹¨ëŠ” ê²Œì„">
    <meta name="keywords" content="ë²½ëŒê¹¨ê¸°, ë²½ëŒ, ê¹¨ê¸°, ê²Œì„, ì›¹ì•±, ì›¹ ì•±, ì›¹ ë„êµ¬, ì›¹ ë„êµ¬ ëª¨ìŒ">
    <meta name="author" content="hughqlee">

    <!-- Open Graph ë©”íƒ€ íƒœê·¸ -->
    <meta property="og:title" content="ë²½ëŒê¹¨ê¸° - SNS ê³µìœ  ê²Œì„">
    <meta property="og:description" content="ë²½ëŒì„ ê¹¨ëŠ” ê²Œì„">
    <meta property="og:image" content="https://hughqlee.com/static/brickbreaker/brickbreaker_thumb.png">
    <meta property="og:url" content="https://hughqlee.com/brickbreaker">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="ko_KR">

    <link rel="canonical" href="https://hughqlee.com/brickbreaker">
    <!-- íŒŒë¹„ì½˜ -->
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='face.png') }}">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='face.png') }}">

    <style>
        :root {
            --navy: #1a237e;
            --green: #4caf50;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .game-container {
            margin: 20px auto;
            text-align: center;
            position: relative;
        }

        .game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        #gameCanvas {
            background: #1a237e; /* ì§™ì€ ë„¤ì´ë¹„ ë ˆíŠ¸ë¡œ ìš°ì£¼ ë°°ê²½ */
            border: 2px solid var(--navy);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #startBtn {
            background-color: var(--navy);
            color: white;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        input[type="text"] {
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }

        .share-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .share-buttons button {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            color: white;
        }

        .threads-btn {
            background-color: #000000;
        }

        .twitter-btn {
            background-color: #1da1f2;
        }

        @media (max-width: 768px) {
            #gameCanvas {
                width: 90vw;
                height: auto;
            }

            button {
                padding: 15px 30px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div id="currentTime">ì‹œê°„: 0.00ì´ˆ</div>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="controls">
            <button id="startBtn">ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <div id="resultModal" class="modal">
        <div class="modal-content">
            <h2 id="resultTitle">ê²Œì„ í´ë¦¬ì–´!</h2>
            <div id="successResult" style="display: block;">
                <p>ì†Œìš” ì‹œê°„: <span id="timeResult">0</span>ì´ˆ</p>
            </div>
            <div id="failResult" style="display: none;">
                <p>í”Œë ˆì´ ì‹œê°„: <span id="failTimeResult">0</span>ì´ˆ</p>
                <p>ë²½ëŒ íŒŒê´´: <span id="bricksDestroyed">0</span>ê°œ / <span id="totalBricks">0</span>ê°œ</p>
                <p>ì§„í–‰ë¥ : <span id="progressRate">0</span>%</p>
            </div>
            <input type="text" id="nickname" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”">
            <div class="share-buttons">
                <button class="threads-btn" onclick="shareThreads()">Threads ê³µìœ </button>
                <button class="twitter-btn" onclick="shareTwitter()">Twitter ê³µìœ </button>
            </div>
        </div>
    </div>

    <ins class="kakao_ad_area" style="display:none;"
    data-ad-unit = "DAN-dR9sN7uSaSj7fSQq"
    data-ad-width = "320"
    data-ad-height = "100"></ins>
    <script type="text/javascript" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script>

    <script>
        // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ (ìµœìƒë‹¨ì— ìœ„ì¹˜)
        let canvas, ctx;
        let gameStarted = false;
        let startTime;
        let clearTime;
        let paddle, balls, bricks, items;
        let paddleWidth = 120, paddleHeight = 18;
        let ballRadius = 10;
        let brickRowCount = 5, brickColCount = 8;
        let brickWidth = 80, brickHeight = 28, brickPadding = 10, brickOffsetTop = 40, brickOffsetLeft = 30;
        let rightPressed = false, leftPressed = false;
        let isGameClear = false;
        let totalBricksCount = 0;
        let gameSuccess = false;
        let destroyedBricksCount = 0; // ì‹¤ì œë¡œ ê¹¨ì§„ ë²½ëŒ ìˆ˜

        // ë§µ ì‚¬ì´ì¦ˆë¥¼ ìº”ë²„ìŠ¤ì— ë§ê²Œ ì¡°ì •
        const MAP_COLS = 40; // 800/20 = 40
        const MAP_ROWS = 30; // 600/20 = 30
        const MAP_BRICK_SIZE = 20;

        // ì•„ì´í…œ íƒ€ì… ì •ì˜
        const ITEM_TYPES = {
            PLUS_ONE: { color: '#4caf50', symbol: '+1' },    // ì´ˆë¡ +1
            MULTIPLY: { color: '#ff9800', symbol: 'x2' }     // ì£¼í™© x2
        };

        // í†µë¡œ ì •ì˜: Uì ëª¨ì„œë¦¬ ë²½ ë³´ì™„ ë° ê°„ê²© í™•ì¥
        function generateMazeMap() {
            // ì „ì²´ 1(ê¹° ìˆ˜ ìˆëŠ” ë²½ëŒ)ë¡œ ì±„ì›€
            let map = Array.from({length: MAP_COLS}, () => Array(MAP_ROWS).fill(1));
            
            const centerX = Math.floor(MAP_COLS / 2);
            
            // 1. 0~16í–‰: ì´ˆë¡ìƒ‰ ê¹° ìˆ˜ ìˆëŠ” ë²½ëŒ (ê°„ê²© í™•ì¥)
            
            // 2. 17í–‰: ê¹° ìˆ˜ ì—†ëŠ” ë²½ (ë” ìœ„ë¡œ ì˜¬ë¦¼)
            for (let x = 0; x < MAP_COLS; x++) {
                map[x][17] = 2; // ê¹° ìˆ˜ ì—†ëŠ” ë²½
            }
            
            // 3. 18í–‰ ì´í›„ëŠ” ëª¨ë‘ ë¹ˆ ê³µê°„ (ë” ë„“ì€ ê°„ê²©)
            for (let y = 18; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    map[x][y] = 0; // ë¹ˆ ê³µê°„
                }
            }
            
            // 4. ì¤‘ì•™ 2ì—´ì„ 7~17í–‰ í†µë¡œ ë§Œë“¤ê¸°
            for (let y = 7; y <= 17; y++) {
                map[centerX - 1][y] = 0; // í†µë¡œ
                map[centerX][y] = 0;     // í†µë¡œ
            }
            
            // 5. Uìí˜• í†µë¡œ (4ê°œ ì—´ë§Œ)
            // 5-1. 7í–‰ì—ì„œ ì™¼ìª½ìœ¼ë¡œ 4ê°œ ì—´ë§Œ í™•ì¥
            for (let x = centerX - 4; x < centerX - 1; x++) { // 4ê°œ ì—´ë§Œ
                if (x >= 0) {
                    map[x][7] = 0;
                    map[x][8] = 0; // 2ì¹¸ ë„“ì´
                }
            }
            
            // 5-2. ì™¼ìª½ ëì—ì„œ ì•„ë˜ë¡œ 5í–‰ í™•ì¥
            const leftX = centerX - 4;
            for (let y = 8; y <= 12; y++) {
                if (leftX >= 0) {
                    map[leftX][y] = 0;
                    map[leftX + 1][y] = 0; // 2ì¹¸ ë„“ì´
                }
            }
            
            // 6. í†µë¡œ ì£¼ë³€ì—ë§Œ ë²½ ì¶”ê°€ (í†µë¡œë¥¼ ë§‰ì§€ ì•Šë„ë¡)
            // ì¤‘ì•™ ì„¸ë¡œ í†µë¡œ ì–‘ìª½
            for (let y = 7; y <= 17; y++) {
                if (centerX - 2 >= 0 && map[centerX - 2][y] === 1) {
                    map[centerX - 2][y] = 2; // ì™¼ìª½ ë²½
                }
                if (centerX + 1 < MAP_COLS && map[centerX + 1][y] === 1) {
                    map[centerX + 1][y] = 2; // ì˜¤ë¥¸ìª½ ë²½
                }
            }
            
            // ìˆ˜í‰ í†µë¡œ ìœ„ì•„ë˜
            for (let x = centerX - 4; x < centerX + 2; x++) {
                if (x >= 0) {
                    if (6 >= 0 && map[x][6] === 1) map[x][6] = 2;
                }
            }
            
            // ì™¼ìª½ ì„¸ë¡œ í†µë¡œ ì–‘ìª½
            const leftWallX = centerX - 5;
            for (let y = 8; y <= 12; y++) {
                if (leftWallX >= 0 && map[leftWallX][y] === 1) {
                    map[leftWallX][y] = 2; // ì™¼ìª½ ë²½
                }
            }
            
            // 7. Uì ëª¨ì„œë¦¬ ë²½ ë³´ì™„
            // ì™¼ìª½ ìœ„ ëª¨ì„œë¦¬
            if (centerX - 6 >= 0 && map[centerX - 6][6] === 1) {
                map[centerX - 5][6] = 2;
            }
            if (centerX - 6 >= 0 && map[centerX - 6][7] === 1) {
                map[centerX - 5][7] = 2;
            }
            
            return map;
        }

        function resetGame() {
            // í‚¤ë³´ë“œ ìƒíƒœ ì´ˆê¸°í™”
            rightPressed = false;
            leftPressed = false;
            
            paddle = {
                x: (canvas.width - paddleWidth) / 2,
                y: canvas.height - paddleHeight - 10,
                width: paddleWidth,
                height: paddleHeight,
                speed: 8
            };
            balls = [{
                x: canvas.width / 2,
                y: canvas.height - paddleHeight - 30,
                dx: 4 * (Math.random() > 0.5 ? 1 : -1), // 5 * 0.8 = 4
                dy: -4.8, // -6 * 0.8 = -4.8
                radius: ballRadius
            }];
            
            // ë²½ëŒ ë°°ì—´ ì™„ì „ ì´ˆê¸°í™”
            bricks = [];
            totalBricksCount = 0;
            destroyedBricksCount = 0; // ê¹¨ì§„ ë²½ëŒ ì¹´ìš´í„° ì´ˆê¸°í™”
            
            // ë§µ ìƒì„± ë° ë²½ëŒ ì´ˆê¸°í™”
            const map = generateMazeMap();
            for (let c = 0; c < MAP_COLS; c++) {
                bricks[c] = [];
                for (let r = 0; r < MAP_ROWS; r++) {
                    bricks[c][r] = { 
                        x: c * MAP_BRICK_SIZE, 
                        y: r * MAP_BRICK_SIZE, 
                        status: map[c][r] 
                    };
                    if (map[c][r] === 1) {
                        totalBricksCount++; // ê¹° ìˆ˜ ìˆëŠ” ë²½ëŒë§Œ ì¹´ìš´íŠ¸
                    }
                }
            }
            
            items = [];
            isGameClear = false;
            gameSuccess = false;
            
            // ì§„í–‰ë¥  ê´€ë ¨ ë³€ìˆ˜ ì´ˆê¸°í™”
            clearTime = 0;
        }

        // íŒ¨ë“¤ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ë¹¨ê°„ìƒ‰ + íŒŒë€ ì¤‘ì•™ì„ )
        function drawPaddle() {
            // ë¹¨ê°„ìƒ‰ íŒ¨ë“¤ ë°°ê²½
            ctx.fillStyle = '#f44336';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            // íŒŒë€ìƒ‰ ì¤‘ì•™ ìˆ˜ì§ì„ 
            ctx.fillStyle = '#2196f3';
            const centerX = paddle.x + paddle.width / 2;
            ctx.fillRect(centerX - 2, paddle.y, 4, paddle.height);
        }

        // ê³µ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ë…¸ë€ìƒ‰)
        function drawBall(ball) {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffeb3b'; // ë…¸ë€ìƒ‰
            ctx.fill();
            ctx.closePath();
        }

        function drawItems() {
            items.forEach(item => {
                // ì•„ì´í…œ ë°°ê²½
                ctx.beginPath();
                ctx.arc(item.x, item.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = item.type.color;
                ctx.globalAlpha = 0.9;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.closePath();
                
                // ì•„ì´í…œ í…ìŠ¤íŠ¸
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.type.symbol, item.x, item.y);
            });
        }

        function drawBricks() {
            for (let c = 0; c < MAP_COLS; c++) {
                for (let r = 0; r < MAP_ROWS; r++) {
                    if (bricks[c][r].status === 1) {
                        // ê¹° ìˆ˜ ìˆëŠ” ë²½ëŒ (ì´ˆë¡)
                        ctx.fillStyle = '#4caf50';
                        ctx.fillRect(bricks[c][r].x, bricks[c][r].y, MAP_BRICK_SIZE, MAP_BRICK_SIZE);
                        ctx.strokeStyle = '#2e7d32';
                        ctx.strokeRect(bricks[c][r].x, bricks[c][r].y, MAP_BRICK_SIZE, MAP_BRICK_SIZE);
                    } else if (bricks[c][r].status === 2) {
                        // ê¹° ìˆ˜ ì—†ëŠ” ë²½ (íšŒìƒ‰)
                        ctx.fillStyle = '#757575';
                        ctx.fillRect(bricks[c][r].x, bricks[c][r].y, MAP_BRICK_SIZE, MAP_BRICK_SIZE);
                        ctx.strokeStyle = '#424242';
                        ctx.strokeRect(bricks[c][r].x, bricks[c][r].y, MAP_BRICK_SIZE, MAP_BRICK_SIZE);
                    }
                }
            }
        }

        // ì •ë°€í•œ ì¶©ëŒ ê°ì§€ ë° ìœ„ì¹˜ ë³´ì • í•¨ìˆ˜
        function checkBallBrickCollision(ball, brick) {
            // ë²½ëŒì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ì¶©ëŒ ì—†ìŒ
            if (brick.status === 0) return false;
            
            // ê³µì˜ ì¤‘ì‹¬ê³¼ ë²½ëŒ ê²½ê³„ ê°„ ê±°ë¦¬ ê³„ì‚°
            const ballCenterX = ball.x;
            const ballCenterY = ball.y;
            const brickLeft = brick.x;
            const brickRight = brick.x + MAP_BRICK_SIZE;
            const brickTop = brick.y;
            const brickBottom = brick.y + MAP_BRICK_SIZE;
            
            // ê³µê³¼ ë²½ëŒì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
            const closestX = Math.max(brickLeft, Math.min(ballCenterX, brickRight));
            const closestY = Math.max(brickTop, Math.min(ballCenterY, brickBottom));
            
            const distanceX = ballCenterX - closestX;
            const distanceY = ballCenterY - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            return distanceSquared <= (ball.radius * ball.radius);
        }

        // ê³µì„ ë²½ ë°–ìœ¼ë¡œ ë°€ì–´ë‚´ëŠ” í•¨ìˆ˜ (ê¹° ìˆ˜ ì—†ëŠ” ë²½ ì²˜ë¦¬ ê°•í™”)
        function resolveBallBrickCollision(ball, brick) {
            const brickCenterX = brick.x + MAP_BRICK_SIZE / 2;
            const brickCenterY = brick.y + MAP_BRICK_SIZE / 2;
            
            // ê³µ ì¤‘ì‹¬ì—ì„œ ë²½ëŒ ì¤‘ì‹¬ìœ¼ë¡œì˜ ë²¡í„°
            const deltaX = ball.x - brickCenterX;
            const deltaY = ball.y - brickCenterY;
            
            // ë²½ëŒ ê²½ê³„ê¹Œì§€ì˜ ê±°ë¦¬
            const halfBrickWidth = MAP_BRICK_SIZE / 2;
            const halfBrickHeight = MAP_BRICK_SIZE / 2;
            
            // X, Y ë°©í–¥ ì¹¨íˆ¬ ê¹Šì´ ê³„ì‚°
            const overlapX = halfBrickWidth + ball.radius - Math.abs(deltaX);
            const overlapY = halfBrickHeight + ball.radius - Math.abs(deltaY);
            
            if (overlapX > 0 && overlapY > 0) {
                // ë” ì‘ì€ ì¹¨íˆ¬ ë°©í–¥ìœ¼ë¡œ ê³µì„ ë°€ì–´ëƒ„
                if (overlapX < overlapY) {
                    // Xë°©í–¥ìœ¼ë¡œ ë°€ì–´ëƒ„
                    const pushDirection = deltaX > 0 ? 1 : -1;
                    ball.x = brickCenterX + pushDirection * (halfBrickWidth + ball.radius);
                    ball.dx = -ball.dx;
                } else {
                    // Yë°©í–¥ìœ¼ë¡œ ë°€ì–´ëƒ„
                    const pushDirection = deltaY > 0 ? 1 : -1;
                    ball.y = brickCenterY + pushDirection * (halfBrickHeight + ball.radius);
                    ball.dy = -ball.dy;
                }
                return true;
            }
            return false;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawPaddle();
            balls.forEach(drawBall);
            drawItems();
        }

        function movePaddle() {
            if (rightPressed && paddle.x < canvas.width - paddle.width) {
                paddle.x += paddle.speed;
            } else if (leftPressed && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }
        }

        // ë²½ëŒ íŒŒê´´ ì‹œ ì¹´ìš´í„° ì¦ê°€ (moveBalls í•¨ìˆ˜ì—ì„œ í˜¸ì¶œ)
        function destroyBrick(brick) {
            if (brick.status === 1) {
                brick.status = 0;
                destroyedBricksCount++; // ì‹¤ì œë¡œ ê¹¨ì§„ ë²½ëŒ ì¹´ìš´íŠ¸ ì¦ê°€
                return true;
            }
            return false;
        }

        function moveBalls() {
            balls.forEach((ball, ballIdx) => {
                // ì´ì „ ìœ„ì¹˜ ì €ì¥
                const prevX = ball.x;
                const prevY = ball.y;
                
                ball.x += ball.dx;
                ball.y += ball.dy;

                // ë²½ ì¶©ëŒ (ìº”ë²„ìŠ¤ ê²½ê³„)
                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                    ball.dx = -ball.dx;
                    ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                }
                if (ball.y - ball.radius < 0) {
                    ball.dy = -ball.dy;
                    ball.y = ball.radius;
                }
                // ë°”ë‹¥ì— ë–¨ì–´ì§
                if (ball.y + ball.radius > canvas.height) {
                    balls.splice(ballIdx, 1);
                    return;
                }
                
                // íŒ¨ë“¤ ì¶©ëŒ
                if (
                    ball.y + ball.radius > paddle.y &&
                    ball.x > paddle.x && ball.x < paddle.x + paddle.width &&
                    ball.y < paddle.y + paddle.height
                ) {
                    ball.dy = -Math.abs(ball.dy);
                    ball.y = paddle.y - ball.radius; // ìœ„ì¹˜ ë³´ì •
                    let hitPoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                    ball.dx = hitPoint * 5.6; // 7 * 0.8 = 5.6
                }
                
                // ë²½ëŒ ì¶©ëŒ (ê¹° ìˆ˜ ì—†ëŠ” ë²½ ì²˜ë¦¬ ê°•í™”)
                let collisionDetected = false;
                for (let c = 0; c < MAP_COLS && !collisionDetected; c++) {
                    for (let r = 0; r < MAP_ROWS && !collisionDetected; r++) {
                        let brick = bricks[c][r];
                        
                        // ë²½ëŒì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°ë§Œ ì¶©ëŒ ì²´í¬ (status 1 ë˜ëŠ” 2)
                        if (brick.status === 1 || brick.status === 2) {
                            if (checkBallBrickCollision(ball, brick)) {
                                // ìœ„ì¹˜ ë³´ì • ë° ë°˜ì‚¬ (ëª¨ë“  ë²½ëŒì— ëŒ€í•´)
                                if (resolveBallBrickCollision(ball, brick)) {
                                    collisionDetected = true;
                                    
                                    // ê¹° ìˆ˜ ìˆëŠ” ë²½ëŒë§Œ íŒŒê´´ (ìˆ˜ì •ëœ ë¶€ë¶„)
                                    if (destroyBrick(brick)) {
                                        // ì•„ì´í…œ ë“œë (5% í™•ë¥ ë¡œ ë‚®ì¶¤)
                                        if (Math.random() < 0.05) {
                                            const itemType = Math.random() < 0.6 ? ITEM_TYPES.PLUS_ONE : ITEM_TYPES.MULTIPLY;
                                            items.push({
                                                x: brick.x + MAP_BRICK_SIZE / 2,
                                                y: brick.y + MAP_BRICK_SIZE / 2,
                                                speed: 2,
                                                type: itemType
                                            });
                                        }
                                    }
                                    // status === 2ì¸ ë²½ì€ íŒŒê´´ë˜ì§€ ì•Šì§€ë§Œ ì¶©ëŒ ì²˜ë¦¬ëŠ” ë¨
                                }
                            }
                        }
                    }
                }
            });
        }

        function moveItems() {
            items.forEach((item, idx) => {
                item.y += item.speed;
                // íŒ¨ë“¤ì— ë‹¿ìœ¼ë©´ ì•„ì´í…œ íš¨ê³¼
                if (
                    item.y + 15 > paddle.y &&
                    item.x > paddle.x && item.x < paddle.x + paddle.width &&
                    item.y < paddle.y + paddle.height
                ) {
                    if (item.type === ITEM_TYPES.PLUS_ONE) {
                        // +1: ë³¼ 1ê°œ ì¶”ê°€
                        if (balls.length > 0) {
                            const sourceBall = balls[0];
                            balls.push({
                                x: sourceBall.x,
                                y: sourceBall.y,
                                dx: sourceBall.dx * 0.8 + Math.random() * 2 - 1,
                                dy: sourceBall.dy * 0.8,
                                radius: sourceBall.radius
                            });
                        }
                    } else if (item.type === ITEM_TYPES.MULTIPLY) {
                        // x2: ë³¼ ê°œìˆ˜ 2ë°°
                        const currentBalls = [...balls];
                        currentBalls.forEach(ball => {
                            balls.push({
                                x: ball.x,
                                y: ball.y,
                                dx: ball.dx * (Math.random() * 0.6 + 0.7) * (Math.random() > 0.5 ? 1 : -1),
                                dy: ball.dy * (Math.random() * 0.6 + 0.7),
                                radius: ball.radius
                            });
                        });
                    }
                    items.splice(idx, 1);
                }
                // ë°”ë‹¥ì— ë–¨ì–´ì§€ë©´ ì‚­ì œ
                else if (item.y - 15 > canvas.height) {
                    items.splice(idx, 1);
                }
            });
        }

        function checkClear() {
            for (let c = 0; c < MAP_COLS; c++) {
                for (let r = 0; r < MAP_ROWS; r++) {
                    if (bricks[c][r].status === 1) return false; // ê¹° ìˆ˜ ìˆëŠ” ë²½ëŒë§Œ ì²´í¬
                }
            }
            return true;
        }

        // ì‹¤ì‹œê°„ ì‹œê°„ ì—…ë°ì´íŠ¸
        function updateCurrentTime() {
            if (gameStarted && !isGameClear) {
                const currentTime = (Date.now() - startTime) / 1000;
                document.getElementById('currentTime').textContent = `ì‹œê°„: ${currentTime.toFixed(2)}ì´ˆ`;
            }
        }

        function gameLoop() {
            if (!gameStarted) return;
            movePaddle();
            moveBalls();
            moveItems();
            updateCurrentTime(); // ì‹œê°„ ì—…ë°ì´íŠ¸ ì¶”ê°€
            draw();
            // ë³¼ì´ ëª¨ë‘ ì‚¬ë¼ì§€ë©´ ê²Œì„ ì˜¤ë²„(ì‹¤íŒ¨ ê²°ê³¼ í‘œì‹œ)
            if (balls.length === 0) {
                gameStarted = false;
                gameSuccess = false;
                showGameResult();
                return;
            }
            // í´ë¦¬ì–´ íŒì •
            if (!isGameClear && checkClear()) {
                isGameClear = true;
                gameStarted = false;
                gameSuccess = true;
                showGameResult();
                return;
            }
            requestAnimationFrame(gameLoop);
        }

        // í‚¤ë³´ë“œ/í„°ì¹˜ ì´ë²¤íŠ¸
        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
            else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
        }
        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
            else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
        }
        function touchStartHandler(e) {
            const x = e.touches[0].clientX;
            if (x > window.innerWidth / 2) rightPressed = true;
            else leftPressed = true;
        }
        function touchEndHandler() {
            rightPressed = false;
            leftPressed = false;
        }

        // window.onloadì—ì„œ ëª¨ë“  ì´ˆê¸°í™”
        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // ìº”ë²„ìŠ¤ í¬ê¸° ë°˜ì‘í˜• ì¡°ì •
            function resizeCanvas() {
                const maxWidth = Math.min(800, window.innerWidth - 40);
                const scale = maxWidth / 800;
                canvas.style.width = maxWidth + 'px';
                canvas.style.height = (600 * scale) + 'px';
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // í‚¤ë³´ë“œ/í„°ì¹˜ ì´ë²¤íŠ¸
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);
            canvas.addEventListener('touchstart', touchStartHandler);
            canvas.addEventListener('touchend', touchEndHandler);

            // ë²„íŠ¼ ì´ë²¤íŠ¸
            document.getElementById('startBtn').addEventListener('click', startGame);

            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” ë° ì²« í™”ë©´ ê·¸ë¦¬ê¸°
            resetGame();
            draw();
        };

        // startGameì—ì„œë„ í‚¤ë³´ë“œ ìƒíƒœ í™•ì‹¤íˆ ì´ˆê¸°í™”
        function startGame() {
            gameStarted = true;
            startTime = Date.now();
            document.getElementById('startBtn').disabled = true;
            
            // í‚¤ë³´ë“œ ìƒíƒœ ê°•ì œ ì´ˆê¸°í™”
            rightPressed = false;
            leftPressed = false;
            
            // ëª¨ë‹¬ ë‹«ê¸°
            document.getElementById('resultModal').style.display = 'none';
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ë¦¬ì…‹
            resetGame();
            draw();
            requestAnimationFrame(gameLoop);
        }
        window.startGame = startGame;

        // ê¹¨ì§„ ë²½ëŒ ê°œìˆ˜ ë°˜í™˜ (ê°„ë‹¨íˆ ì¹´ìš´í„° ë°˜í™˜)
        function getDestroyedBricksCount() {
            return destroyedBricksCount;
        }

        // ì§„í–‰ë¥  ê³„ì‚° í•¨ìˆ˜ (ì•ˆì „ì„± ê°•í™”)
        function getProgressRate() {
            if (totalBricksCount === 0) return 0;
            return Math.round((destroyedBricksCount / totalBricksCount) * 100);
        }

        // í†µí•©ëœ ê²Œì„ ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function showGameResult() {
            clearTime = (Date.now() - startTime) / 1000;
            
            if (gameSuccess) {
                // ì„±ê³µ ì‹œ
                document.getElementById('resultTitle').textContent = 'ğŸ‰ ê²Œì„ í´ë¦¬ì–´!';
                document.getElementById('successResult').style.display = 'block';
                document.getElementById('failResult').style.display = 'none';
                document.getElementById('timeResult').textContent = clearTime.toFixed(2);
            } else {
                // ì‹¤íŒ¨ ì‹œ
                document.getElementById('resultTitle').textContent = 'ğŸ˜¢ ê²Œì„ ì‹¤íŒ¨!';
                document.getElementById('successResult').style.display = 'none';
                document.getElementById('failResult').style.display = 'block';
                document.getElementById('failTimeResult').textContent = clearTime.toFixed(2);
                document.getElementById('bricksDestroyed').textContent = getDestroyedBricksCount();
                document.getElementById('totalBricks').textContent = totalBricksCount;
                document.getElementById('progressRate').textContent = getProgressRate();
            }
            
            document.getElementById('resultModal').style.display = 'flex';
            document.getElementById('currentTime').textContent = 'ì‹œê°„: 0.00ì´ˆ';
        }

        // ê²Œì„ í´ë¦¬ì–´ (ê¸°ì¡´ í•¨ìˆ˜ëŠ” showGameResultë¡œ í†µí•©)
        function gameClear() {
            showGameResult();
        }

        // SNS ê³µìœ  í•¨ìˆ˜ë“¤ (ì„±ê³µ/ì‹¤íŒ¨ êµ¬ë¶„ ë©”ì‹œì§€)
        function getShareMessage() {
            const nickname = document.getElementById('nickname').value || 'ìµëª…';
            const time = clearTime.toFixed(2);
            
            if (gameSuccess) {
                return `ğŸ® ${nickname}ë‹˜ì´ ë²½ëŒê¹¨ê¸°ë¥¼ ${time}ì´ˆ ë§Œì— í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤!\n\nğŸ•¹ï¸ ê²Œì„ í”Œë ˆì´: hughqlee.com/brickbreaker\nâ­ ë‹¹ì‹ ë„ ë„ì „í•´ë³´ì„¸ìš”!`;
            } else {
                const progress = getProgressRate();
                const destroyed = getDestroyedBricksCount();
                return `ğŸ® ${nickname}ë‹˜ì´ ë²½ëŒê¹¨ê¸°ì— ë„ì „í–ˆìŠµë‹ˆë‹¤!\nâ±ï¸ í”Œë ˆì´ ì‹œê°„: ${time}ì´ˆ\nğŸ§± ë²½ëŒ íŒŒê´´: ${destroyed}ê°œ (${progress}% ë‚¨ìŒ)\n\nğŸ•¹ï¸ ê²Œì„ í”Œë ˆì´: hughqlee.com/brickbreaker\nâ­ ë‹¹ì‹ ë„ ë„ì „í•´ë³´ì„¸ìš”!`;
            }
        }

        function shareThreads() {
            const message = getShareMessage();
            const url = `https://threads.net/intent/post?text=${encodeURIComponent(message)}`;
            window.open(url, '_blank', 'width=600,height=400');
        }

        function shareTwitter() {
            const message = getShareMessage();
            const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
            window.open(url, '_blank', 'width=600,height=400');
        }
    </script>
</body>
</html>
